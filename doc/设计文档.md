
目标: 制作一款能够自由扩展语法, 对语法元素拥有绝对控制能力的语言

语言类别: 静态, 强类型, 安全性高, 适合超大型工程, 极其高效

语言主要任务:
实现自举的静态语言, 作为C++的替代品, 需要能够完全实现面向对象, 同时提供兼容底层C库的操作
制作一款安全易用的多范式编程语言, 并且各个范式间可以混合使用
可以对代码进行多个层级的建模

主要语言特性:

1. 函数的多返回值和重载

```
public func hello(int a, int b) -> int {

}

// 支持重载, 多返回, 在导出成C函数时, 可以用attrbute设定名称, 否则将自动添加新的后缀用于重命名
@attr(name='hello2')
public func hello(int a, int b, int c) -> int, int { 

}

func main() {
    int a, b = hello(12, 3)
}

```


2. 基本变量类型

小写的内置类型均为值类型
整数
int(定义为int32), int8, int16, int32, int64
无符号整数
uint(定义为uint32), uint8, uint16, uint32, uint64
字符, 字符串 (这部分实际上是库扩展的)
char, string
布尔 (库扩展的)
bool
浮点
float, double
通用变量 (库扩展的)
var
自动推断 (库扩展的)
auto

实际上, 在不引用任何库的情况下, 只有
int8, int16, int32, int64, 
uint8, uint16, uint32, uint64
和 float, double


3. 符合标准LLVM格式的二进制库

语言的库符合LLVM IR标准, 使用metadata存储额外的编译信息
这样一个文件在载入后, 完全等同于载入源代码, 只不过具体的函数都被编译成了二进制, 丢失了这些函数的源代码信息而已
但包名, 文件名, 符号名, 以及宏和所有需要的符号类型信息都得以保留.

而且, 该文件可以和其他库链接, 形成一个库


4. 最小编译单元

文件是最小编译单元, 包是最小组织单元.
每个文件可以视为一个独立的编译环境, 其他文件import的符号和宏不会作用于当前文件.
但包是最小的组织单元, 每次编译, 最少应编译一整个包, 因为包内符号是互相能够看到的, 而且包内符号没有顺序之分, 一个包编译后整体作为一个LLVM IR文件,
并以包名作为输出
当然单个文件可以作为一个包, 几个文件也可以, 一个或多个目录也可以, 甚至是一个递归搜索的目录也可以

包同时也是一个命名空间, 故包也是可以嵌套存在的


5. 宏翻译模型

每次匹配一段语法序列中的内容, 尝试去匹配最接近的内容, 并以此结构作为匹配上的语法进行宏翻译, 翻译出新的内容后就按照普通代码来处理
宏翻译能够动态扩展语法, 而且根据宏定义的位置不同(或引用位置不同) 该定义存在生存周期

例如:
```
func hello() {
    import 'string'
    // this import will only available in this scope
}
```

同时, 宏翻译模型还可以用于语法检查的扩展
例如, 我们可以对未初始化变量进行检查, 这部分扩展可以用宏来实现, 通过向回调链注册这个宏, 实现在特定语法处理的时候, 用该宏进行前处理和后处理


宏翻译的方式其实就是将一段匹配上的内容根据语法格式进行提取和转换, 例如: 
```
int a, b


defmacro (Type type, ID[] ids) {
    return (settype type ids)
}

or

defmacro (Type type, ID[] ids[]) {
    for id in ids:
        yield (settype type id)
}

```



6. 安全的内存模型
